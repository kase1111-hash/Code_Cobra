#!/usr/bin/env python3
"""
Exploit tests for Autonomous Coding Ensemble System.

Tests resistance to common attack vectors: SQLi, XSS, buffer overflow,
command injection, path traversal, and other OWASP Top 10 vulnerabilities.
"""

import json
import os
import sys
import tempfile
import unittest

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from autonomous_ensemble import Config, GuideLoader, Checkpoint


class TestSQLInjection(unittest.TestCase):
    """Test SQL injection resistance."""

    SQL_INJECTION_PAYLOADS = [
        "'; DROP TABLE users; --",
        "1' OR '1'='1",
        "1; DELETE FROM users WHERE 1=1; --",
        "' UNION SELECT * FROM passwords --",
        "1' AND (SELECT COUNT(*) FROM users) > 0 --",
        "admin'--",
        "' OR 1=1--",
        "1' WAITFOR DELAY '00:00:10'--",
        "1'; EXEC xp_cmdshell('dir'); --",
    ]

    def test_guide_loader_sqli_in_steps(self):
        """Guide loader treats SQL injection payloads as plain text."""
        for payload in self.SQL_INJECTION_PAYLOADS:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write(f"Step 1: Execute {payload}\n")
                f.flush()

                loader = GuideLoader(f.name)
                steps = loader.load()

                # Payload should be stored as plain text, not executed
                self.assertEqual(len(steps), 1)
                self.assertIn(payload, steps[0])

            os.unlink(f.name)

    def test_config_sqli_in_values(self):
        """Config handles SQL injection payloads in values safely."""
        for payload in self.SQL_INJECTION_PAYLOADS:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                json.dump({"model_a": payload}, f)
                f.flush()

                config = Config.from_json(f.name)
                # Should store as plain string
                self.assertEqual(config.model_a, payload)

            os.unlink(f.name)


class TestXSSAttacks(unittest.TestCase):
    """Test XSS (Cross-Site Scripting) resistance."""

    XSS_PAYLOADS = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "<body onload=alert('XSS')>",
        "<iframe src='javascript:alert(1)'>",
        "'-alert(1)-'",
        "\"><script>alert(document.cookie)</script>",
        "<img src=\"x\" onerror=\"eval(atob('YWxlcnQoMSk='))\">",
        "<div onclick=\"alert('XSS')\">Click</div>",
    ]

    def test_guide_loader_xss_in_steps(self):
        """Guide loader treats XSS payloads as plain text."""
        for payload in self.XSS_PAYLOADS:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write(f"Step 1: Display {payload}\n")
                f.flush()

                loader = GuideLoader(f.name)
                steps = loader.load()

                # Payload should be stored as plain text
                self.assertEqual(len(steps), 1)
                # Step should contain the description (after "Step 1: ")
                self.assertIn("Display", steps[0])

            os.unlink(f.name)

    def test_checkpoint_xss_in_output(self):
        """Checkpoint stores XSS payloads without interpretation."""
        from datetime import datetime

        for payload in self.XSS_PAYLOADS:
            with tempfile.TemporaryDirectory() as tmpdir:
                checkpoint_file = os.path.join(tmpdir, "checkpoint.json")
                checkpoint = Checkpoint(
                    guide_file="test.txt",
                    spec=f"Test with {payload}",
                    completed_steps=1,
                    cumulative_output=payload,
                    step_outputs=[payload],
                    timestamp=datetime.now().isoformat()
                )
                checkpoint.save(checkpoint_file)
                loaded = Checkpoint.load(checkpoint_file)

                # Should store verbatim
                self.assertEqual(loaded.cumulative_output, payload)
                self.assertEqual(loaded.step_outputs[0], payload)


class TestBufferOverflow(unittest.TestCase):
    """Test buffer overflow resistance."""

    def test_extremely_long_step_description(self):
        """System handles extremely long step descriptions."""
        long_string = "A" * (10 * 1024 * 1024)  # 10MB

        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write(f"Step 1: {long_string}\n")
            f.flush()

            loader = GuideLoader(f.name)
            steps = loader.load()

            self.assertEqual(len(steps), 1)
            self.assertIn(long_string[:100], steps[0])

        os.unlink(f.name)

    def test_many_steps_no_overflow(self):
        """System handles files with many steps."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            for i in range(10000):
                f.write(f"Step {i+1}: Action number {i+1}\n")
            f.flush()

            loader = GuideLoader(f.name)
            steps = loader.load()

            self.assertEqual(len(steps), 10000)

        os.unlink(f.name)

    def test_deeply_nested_json_config(self):
        """Config handles deeply nested JSON without stack overflow."""
        # Create deeply nested structure
        nested = {"value": "test"}
        for _ in range(100):
            nested = {"nested": nested}

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump({"model_a": "test", "extra": nested}, f)
            f.flush()

            # Should load without stack overflow
            config = Config.from_json(f.name)
            self.assertEqual(config.model_a, "test")

        os.unlink(f.name)


class TestCommandInjection(unittest.TestCase):
    """Test command injection resistance."""

    CMD_INJECTION_PAYLOADS = [
        "$(whoami)",
        "`id`",
        "; ls -la",
        "| cat /etc/passwd",
        "& ping -c 1 localhost",
        "\n/bin/sh",
        "${IFS}cat${IFS}/etc/passwd",
        "$((1+1))",
        "$(touch /tmp/pwned)",
        "`touch /tmp/pwned`",
    ]

    def test_guide_step_no_command_execution(self):
        """Guide steps don't execute shell commands."""
        # Use payloads that don't have newlines (which would split the step)
        safe_payloads = [p for p in self.CMD_INJECTION_PAYLOADS if '\n' not in p]
        for payload in safe_payloads:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write(f"Step 1: Run {payload}\n")
                f.flush()

                loader = GuideLoader(f.name)
                steps = loader.load()

                # Should be plain text
                self.assertIn(payload, steps[0])
                # Verify no file was created (if payload was trying to create one)
                self.assertFalse(os.path.exists("/tmp/pwned"))

            os.unlink(f.name)

    def test_config_values_no_command_execution(self):
        """Config values don't execute shell commands."""
        for payload in self.CMD_INJECTION_PAYLOADS:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                json.dump({"model_a": payload}, f)
                f.flush()

                config = Config.from_json(f.name)
                # Should be stored as string
                self.assertEqual(config.model_a, payload)

            os.unlink(f.name)


class TestPathTraversal(unittest.TestCase):
    """Test path traversal attack resistance."""

    PATH_TRAVERSAL_PAYLOADS = [
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\config\\sam",
        "/etc/passwd",
        "....//....//....//etc/passwd",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        "..%252f..%252f..%252fetc%252fpasswd",
        "/var/log/../../../etc/passwd",
    ]

    def test_guide_loader_rejects_traversal_paths(self):
        """Guide loader handles path traversal attempts safely."""
        for payload in self.PATH_TRAVERSAL_PAYLOADS:
            # Attempting to load from traversal path should fail safely
            loader = GuideLoader(payload)
            try:
                steps = loader.load()
                # If it somehow succeeds, shouldn't expose sensitive data
                self.assertFalse(any("root:" in s for s in steps))
            except (FileNotFoundError, PermissionError, OSError, ValueError):
                # Expected behavior - reject invalid paths
                # ValueError occurs when file exists but has no valid steps
                pass


class TestFormatStringAttacks(unittest.TestCase):
    """Test format string vulnerability resistance."""

    FORMAT_STRING_PAYLOADS = [
        "%s%s%s%s%s%s%s%s%s%s",
        "%x%x%x%x%x%x%x%x",
        "%n%n%n%n%n%n%n%n",
        "{0}{1}{2}{3}{4}",
        "${7*7}",
        "{{7*7}}",
        "%d%d%d%d%d%d%d%d%d%d",
    ]

    def test_guide_loader_format_string_safe(self):
        """Guide loader treats format strings as plain text."""
        for payload in self.FORMAT_STRING_PAYLOADS:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
                f.write(f"Step 1: Print {payload}\n")
                f.flush()

                loader = GuideLoader(f.name)
                steps = loader.load()

                # Should be stored verbatim
                self.assertIn(payload, steps[0])

            os.unlink(f.name)


class TestXXEInjection(unittest.TestCase):
    """Test XXE (XML External Entity) injection resistance."""

    def test_json_config_not_xml(self):
        """Config uses JSON, not XML, avoiding XXE entirely."""
        # JSON parsers are not vulnerable to XXE
        xxe_payload = """<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<config><model_a>&xxe;</model_a></config>"""

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            # Write invalid JSON (XML content)
            f.write(xxe_payload)
            f.flush()

            # Should fail to parse, not expose /etc/passwd
            with self.assertRaises(json.JSONDecodeError):
                Config.from_json(f.name)

        os.unlink(f.name)


class TestSerializationAttacks(unittest.TestCase):
    """Test deserialization attack resistance."""

    def test_json_no_code_execution(self):
        """JSON parsing doesn't execute arbitrary code."""
        malicious_json = {
            "__class__": "os.system",
            "__reduce__": ["os.system", ["whoami"]],
            "__init__": "__import__('os').system('whoami')",
        }

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(malicious_json, f)
            f.flush()

            # JSON.load is safe - won't execute code
            config = Config.from_json(f.name)
            # Even if keys are stored, they're just data, not executable
            # The key point is that JSON parsing is safe and doesn't
            # invoke __reduce__ or other magic methods
            self.assertIsInstance(config, Config)
            # Verify the system wasn't compromised
            import subprocess
            result = subprocess.run(['whoami'], capture_output=True, text=True)
            # If code executed, it would have printed output, but config
            # should just store the string value, not execute it

        os.unlink(f.name)

    def test_checkpoint_no_pickle_usage(self):
        """Checkpoint uses JSON, not pickle, avoiding deserialization attacks."""
        from datetime import datetime

        with tempfile.TemporaryDirectory() as tmpdir:
            checkpoint_file = os.path.join(tmpdir, "checkpoint.json")
            checkpoint = Checkpoint(
                guide_file="test.txt",
                spec="Test",
                completed_steps=1,
                cumulative_output="Output",
                step_outputs=["Step 1"],
                timestamp=datetime.now().isoformat()
            )
            checkpoint.save(checkpoint_file)

            # Verify it's JSON format
            with open(checkpoint_file) as f:
                content = f.read()
                # Should be valid JSON
                data = json.loads(content)
                self.assertIn("guide_file", data)


class TestPrototypePolllution(unittest.TestCase):
    """Test prototype pollution resistance (relevant for embedded JS)."""

    def test_config_ignores_proto_keys(self):
        """Config ignores __proto__ and similar dangerous keys."""
        malicious_keys = {
            "__proto__": {"admin": True},
            "constructor": {"prototype": {"admin": True}},
            "prototype": {"admin": True},
        }

        for key, value in malicious_keys.items():
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                json.dump({"model_a": "test", key: value}, f)
                f.flush()

                config = Config.from_json(f.name)
                # Normal values should work
                self.assertEqual(config.model_a, "test")
                # Dangerous keys should be ignored
                self.assertFalse(hasattr(config, key))

            os.unlink(f.name)


class TestNullByteInjection(unittest.TestCase):
    """Test null byte injection resistance."""

    def test_guide_loader_handles_null_bytes(self):
        """Guide loader handles null bytes in content."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as f:
            f.write("Step 1: Test\x00hidden data\n")
            f.write("Step 2: Normal step\n")
            f.flush()

            loader = GuideLoader(f.name)
            steps = loader.load()

            # Should handle gracefully
            self.assertEqual(len(steps), 2)

        os.unlink(f.name)

    def test_config_json_handles_null_bytes(self):
        """Config handles null bytes in JSON values."""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            # JSON with null byte in string
            f.write('{"model_a": "test\\u0000hidden"}')
            f.flush()

            config = Config.from_json(f.name)
            # Should parse successfully
            self.assertIn("test", config.model_a)

        os.unlink(f.name)


class TestUnicodeAttacks(unittest.TestCase):
    """Test Unicode-based attack resistance."""

    UNICODE_PAYLOADS = [
        "\u202e\u0070\u0061\u0073\u0073\u0077\u006f\u0072\u0064",  # RTL override
        "\ufeff",  # BOM
        "\u0000",  # Null
        "\u2028",  # Line separator
        "\u2029",  # Paragraph separator
        "\uff1c\uff53\uff43\uff52\uff49\uff50\uff54\uff1e",  # Fullwidth <script>
    ]

    def test_guide_loader_handles_unicode_attacks(self):
        """Guide loader handles Unicode attack payloads."""
        for payload in self.UNICODE_PAYLOADS:
            try:
                with tempfile.NamedTemporaryFile(mode='w', suffix='.txt',
                                                   delete=False, encoding='utf-8') as f:
                    f.write(f"Step 1: Test {payload} end\n")
                    f.flush()

                    loader = GuideLoader(f.name)
                    steps = loader.load()

                    # Should load without crashing
                    self.assertEqual(len(steps), 1)

                os.unlink(f.name)
            except (UnicodeEncodeError, UnicodeDecodeError, ValueError):
                # Some payloads may not be encodable or may break step format
                # ValueError occurs when step parsing fails - that's ok
                pass


if __name__ == "__main__":
    unittest.main(verbosity=2)
